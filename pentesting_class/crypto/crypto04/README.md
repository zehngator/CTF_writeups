## CTF: Cryptographic Analysis Fall AY25
Challenge: Custom encryption 

Category: crypto

Points:

Difficulty: Intermediate

## Instructions

Can you get sense of this code file and write the function that will decode the given encrypted file content.
Find the encrypted file here flag_info and code file might be good to analyze and get the flag.  
Hint:  
1. 
Haqrefgnaqvat rapelcgvba nytbevguz gb pbzr hc jvgu qrpelcgvba nytbevguz.

## Solution
I need to read and understand the encryptions process in order to make dcryption code for the flag

The encryption can be broken down into 3 seprate parts

The first part I have to do is to find the key by going backward against this code

The numbers I have so far for the key are 

> a = 88  
> b = 26

I by looking at the first part of the code the first thing that I am looking for is a prime number with n 10 digits above both a and b to find p and g


        def test(plain_text, text_key):             
    p = 97                                                                                                                                                                                                                                  
    g = 31                                                                                                                                                                                                                                  
    if not is_prime(p) and not is_prime(g):                                                                                                                                                                                                 
        print("Enter prime numbers")                                                                                                                                                                                                        
        return                                                                                                                                                                                                                              
    a = randint(p-10, p)                                                                                                                                                                                                                    
    b = randint(g-10, g)                                                                                                                                                                                                                    
    print(f"a = {a}")                                                                                                                                                                                                                       
    print(f"b = {b}")

so the range I am looking in for a is 89-98
There are 2 in that range both 89 and 97

For b the range is 27-36
There are also 2 both 29 and 31

p = 89 or 97 
g = 29 or 31

The next step involves undoing the genorator function a few time

    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)

        def generator(g, x, p):                                                                 
    return pow(g, x) % p       


    shared_key = None
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    semi_cipher = dynamic_xor_encrypt(plain_text, text_key) 
    cipher = encrypt(semi_cipher, shared_key)
    print(f'cipher is: {cipher}')

After talking with some people after class I have discovered that I was giong at it all wrong and need to goolge and find out better how to write a custom dycription code or use chat gpt.

After doing research on how to make a decrytion program I was lost so I turned to chat GPT to write a code dycrptioncode which produced this [code](decryption.py).

and resulted in this output:

    Decrypted text: picoCTF{custom_d2cr0pt6d_019c831c}

I then analyzed the two code to see the diffrence and how it made the decryption based off of th encyption to better understand how It peiced it together and commented on all the changed lines for future refernece 

The two most changed sections are:  

    The dynamic_xor_ section  
            def dynamic_xor_decrypt(cipher_text, text_key):                                                                     
        plaintext = ""
        key_length = len(text_key)
        for i, char in enumerate(cipher_text):#replacing the plain text with the cipher text which allows for the cipher
    text to be Xored bringing it back to its original stat
            key_char = text_key[i % key_length]
            decrypted_char = chr(ord(char) ^ ord(key_char))
            plaintext = decrypted_char + plaintext  # Rebuild the original string by reversing the XORed reversal
        return plaintext
&nbsp;

    Encrypt -> Decrypt section:  
            def decrypt(cipher, shared_key):
        decrypted_chars = []
        for value in cipher:#did the oppisite of encrypt having the values of cipher whole number divied by the shared_k
    ey * 311 giving the original character value
            #The chr automaicaly turns it into a ascii character.
            decrypted_char = chr(value // (shared_key * 311))
            decrypted_chars.append(decrypted_char)
        return ''.join(decrypted_chars)


[ChatGPT Transcript](GPT_Transcript)

## Flag

picoCTF{custom_d2cr0pt6d_019c831c}

## Mitigation
A mitigation for this would be to personlly know the a, b values. By keeping a simple part of the key more hidden it makes it much harder to decode but still could be brute forced thorugh. 
