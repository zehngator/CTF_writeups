#########Input###############
write a decryption code for this encryption program
#!/usr/bin/python3
from random import randint
import sys


def generator(g, x, p):
    return pow(g, x) % p


def encrypt(plaintext, key):
    cipher = []
    for char in plaintext:
        cipher.append(((ord(char) * key*311)))
    return cipher


def is_prime(p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v > 1:
        return False
    else:
        return True


def dynamic_xor_encrypt(plaintext, text_key):
    cipher_text = ""
    key_length = len(text_key)
    for i, char in enumerate(plaintext[::-1]):
        key_char = text_key[i % key_length]
        encrypted_char = chr(ord(char) ^ ord(key_char))
        cipher_text += encrypted_char
    return cipher_text


def test(plain_text, text_key):
    p = 97
    g = 31
    if not is_prime(p) and not is_prime(g):
        print("Enter prime numbers")
        return
    a = randint(p-10, p)
    b = randint(g-10, g)
    print(f"a = {a}")
    print(f"b = {b}")
    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)
    shared_key = None
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)
    cipher = encrypt(semi_cipher, shared_key)
    print(f'cipher is: {cipher}')


if __name__ == "__main__":
    message = sys.argv[1]
    test(message, "trudeau")


To decrypt this encrypted flag
a = 88
b = 26
cipher is: [97965, 185045, 740180, 946995, 1012305, 21770, 827260, 751065, 718410, 457170, 0, 903455, 228585, 54425, 740180, 0, 239470, 936110, 10885, 674870, 261240, 293895, 65310, 65310, 185045, 65310, 283010, 555135, 348320, 533365, 283010, 76195, 130620, 185045]
#########Output##############
To write a decryption program for the encryption code provided, you need to reverse the steps that were performed during the encryption. Here's a breakdown of what happens during encryption:

1. **Key Generation:**
   - The encryption code generates a shared key based on Diffie-Hellman key exchange using the values `g`, `p`, `a`, and `b`. This shared key is then used in the encryption process.

2. **Dynamic XOR Encryption:**
   - The plaintext message is first reversed and XORed with a repeating key (in this case, `"trudeau"`).

3. **Multiplication Encryption:**
   - The dynamically XORed text is then converted to its ASCII values, and each ASCII value is multiplied by the shared key and a constant `311`.

To decrypt the message, we'll need to reverse these steps:
1. Divide each cipher value by the shared key and `311` to recover the dynamically XORed text.
2. Perform the XOR decryption using the same key (`"trudeau"`) to reverse the XOR encryption.

### Steps to Decrypt:

1. **Recalculate the Shared Key:**
   We already know that `a = 88`, `b = 26`, `g = 31`, and `p = 97`. So, we can use the same key generation function to recreate the shared key.

2. **Reverse Multiplication Encryption:**
   Divide each encrypted character by the shared key and `311`.

3. **Reverse XOR Encryption:**
   Use the reverse of the XOR operation to get back the original plaintext.

### Decryption Code:

```python
from random import randint


def generator(g, x, p):
    return pow(g, x) % p


def is_prime(p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v > 1:
        return False
    else:
        return True


def dynamic_xor_decrypt(cipher_text, text_key):
    plaintext = ""
    key_length = len(text_key)
    for i, char in enumerate(cipher_text):
        key_char = text_key[i % key_length]
        decrypted_char = chr(ord(char) ^ ord(key_char))
        plaintext = decrypted_char + plaintext  # Rebuild the original string by reversing the XORed reversal
    return plaintext


def decrypt(cipher, shared_key):
    decrypted_chars = []
    for value in cipher:
        decrypted_char = chr(value // (shared_key * 311))
        decrypted_chars.append(decrypted_char)
    return ''.join(decrypted_chars)


def test_decryption(cipher, text_key):
    p = 97
    g = 31
    a = 88
    b = 26
    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)
    
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    
    # Step 1: Reverse the multiplication and get XOR-encrypted message
    semi_cipher = decrypt(cipher, shared_key)
    
    # Step 2: Reverse the XOR encryption
    plain_text = dynamic_xor_decrypt(semi_cipher, text_key)
    
    print(f'Decrypted text: {plain_text}')


if __name__ == "__main__":
    cipher = [97965, 185045, 740180, 946995, 1012305, 21770, 827260, 751065, 718410, 457170, 0, 903455, 228585, 54425, 740180, 0, 239470, 936110, 10885, 674870, 261240, 293895, 65310, 65310, 185045, 65310, 283010, 555135, 348320, 533365, 283010, 76195, 130620, 185045]
    
    # Decrypt the message using the known text_key
    test_decryption(cipher, "trudeau")
```

### Explanation:
1. **Key Generation:** The key is generated using the same Diffie-Hellman method (`a = 88`, `b = 26`, `g = 31`, `p = 97`).
2. **Reverse Multiplication Encryption:** The `decrypt` function divides each value in the cipher by `shared_key * 311` to retrieve the original XOR-encrypted characters.
3. **Reverse XOR Encryption:** The `dynamic_xor_decrypt` function XORs each character back with the original key (`"trudeau"`) and reverses the text to get the original message.

### Output:
This program will print the decrypted message based on the given cipher values.
