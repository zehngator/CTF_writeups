from random import randint


def generator(g, x, p):
    return pow(g, x) % p

#Not nessesary in this case as 
def is_prime(p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v > 1:
        return False
    else:
        return True


def dynamic_xor_decrypt(cipher_text, text_key):
    plaintext = ""
    key_length = len(text_key)
    for i, char in enumerate(cipher_text):#replacing the plain text with the cipher text which allows for the cipher text to be Xored bringing it back to its original stat
        key_char = text_key[i % key_length]
        decrypted_char = chr(ord(char) ^ ord(key_char))
        plaintext = decrypted_char + plaintext  # Rebuild the original string by reversing the XORed reversal
    return plaintext


def decrypt(cipher, shared_key):
    decrypted_chars = []
    for value in cipher:#did the oppisite of encrypt having the values of cipher whole number divied by the shared_key * 311 giving the original character value
        #The chr automaicaly turns it into a ascii character.
        decrypted_char = chr(value // (shared_key * 311))
        decrypted_chars.append(decrypted_char)
    return ''.join(decrypted_chars)

#Simplified number gen since a and be are given in the enc_flag
def test_decryption(cipher, text_key):
    p = 97
    g = 31
    a = 88
    b = 26
    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)#generating the same keys that were used in original encryption
    
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    
    # Step 1: Reverse the multiplication and get XOR-encrypted message
    semi_cipher = decrypt(cipher, shared_key)
    
    # Step 2: Reverse the XOR encryption
    plain_text = dynamic_xor_decrypt(semi_cipher, text_key)
    
    print(f'Decrypted text: {plain_text}')


if __name__ == "__main__":
    cipher = [97965, 185045, 740180, 946995, 1012305, 21770, 827260, 751065, 718410, 457170, 0, 903455, 228585, 54425, 740180, 0, 239470, 936110, 10885, 674870, 261240, 293895, 65310, 65310, 185045, 65310, 283010, 555135, 348320, 533365, 283010, 76195, 130620, 185045]
    
    # Decrypt the message using the known text_key
    test_decryption(cipher, "trudeau")

