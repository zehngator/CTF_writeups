## CTF: [Reverse Engineering] [Fall AY25]
Challenge: 

Category:   RE

Points:

Difficulty: [ Introductory | Intermediate

## Instructions
What does asm1(0x6fa) return? Submit the flag as a hexadecimal value (starting with '0x'). NOTE: Your submission for this question will NOT be in the normal flag format. Source

## Solution
x86 assembly - calling conversation


ebp points to bottom of the stack
esp points to the top of the stack

asm1:
	<+0>:	push   ebp
	<+1>:	mov    ebp,esp
    #Function prologue

	<+3>:	cmp    DWORD PTR [ebp+0x8],0x3a2
	<+10>:	jg     0x512 <asm1+37>
    # If 0x6fa > 0x3a2, jump to asm1+37

	<+12>:	cmp    DWORD PTR [ebp+0x8],0x358
	<+19>:	jne    0x50a <asm1+29>
	<+21>:	mov    eax,DWORD PTR [ebp+0x8]
	<+24>:	add    eax,0x12
	<+27>:	jmp    0x529 <asm1+60>
	<+29>:	mov    eax,DWORD PTR [ebp+0x8]
	<+32>:	sub    eax,0x12
	<+35>:	jmp    0x529 <asm1+60>

    #based on argument value, definently jum pere
	<+37>:	cmp    DWORD PTR [ebp+0x8],0x6fa
    #compare argument to 0x6fa
    #will not jump, they are equal

	<+44>:	jne    0x523 <asm1+54>
	<+46>:	mov    eax,DWORD PTR [ebp+0x8]
    #eax = 0x6fa
	<+49>:	sub    eax,0x12
    #eax = eax -18

	<+52>:	jmp    0x529 <asm1+60>
	<+54>:	mov    eax,DWORD PTR [ebp+0x8]
	<+57>:	add    eax,0x12

    #Function epilogue
	<+60>:	pop    ebp
	<+61>:	ret    

eax is returned

## Flag

[ The flag here ]

## Mitigation

[ Describe the security issue that this problem highlights ]
[ What action could you take or what code could you modify to protect an organization with this vulnerability? ]
