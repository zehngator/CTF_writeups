## CTF: [Reverse Engineering] [Fall AY25]
Challenge: 

Category:   RE

Points:

Difficulty: [ Introductory | Intermediate

## Instructions


## Solution

    public boolean checkPassword(String password) {
        if (password.length() != 32) {
            return false;
        }
        char[] buffer = new char[32];
        int i;
        for (i=0; i<8; i++) {
            buffer[i] = password.charAt(i);
        }
        for (; i<16; i++) {
            buffer[i] = password.charAt(23-i);
        }
        for (; i<32; i+=2) {
            buffer[i] = password.charAt(46-i);
        }
        for (i=31; i>=17; i-=2) {
            buffer[i] = password.charAt(i);
        }
        String s = new String(buffer);
        return s.equals("jU5t_a_sna_3lpm18gb41_u_4_mfr340");

password must be 32 chars  

index 0- 7 
normal 

index 8-15  
takes char at 23 - current position

index 16 - 32  by 2 
46 - current place  

index 31 - 17 by -2  
just its position 

picoCTF{jU5t_a_s1mpl3_an40r4m_4_u_1fb380}

## Flag

[ The flag here ]

## Mitigation

[ Describe the security issue that this problem highlights ]
[ What action could you take or what code could you modify to protect an organization with this vulnerability? ]
