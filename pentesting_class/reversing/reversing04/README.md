## CTF: Reverse Engineering [Fall AY25]
Challenge: Bit-O-Asm-4 

Category:   RE

Points:

Difficulty: Intermediate

## Instructions
Can you figure out what is in the eax register? Put your answer in the picoCTF flag format: picoCTF{n} where n is the contents of the eax register in the decimal number base. If the answer was 0x11 your flag would be picoCTF{17}.  
Download the assembly dump [here](disassebler-dump0_d.txt).

## Solution
I need to decode the binary 


<+0>:     endbr64   
<+4>:     push   rbp  
<+5>:     mov    rbp,rsp  
#prolouge 

<+8>:     mov    DWORD PTR [rbp-0x14],edi argc  
<+11>:    mov    QWORD PTR [rbp-0x20],rsi argv  
#argc, argv calls

<+15>:    mov    DWORD PTR [rbp-0x4],0x9fe1a  
#creating a int variable

<+22>:    cmp    DWORD PTR [rbp-0x4],0x2710  
#compare var and number  
<+29>:    jle      0x55555555514e <main+37>  
#uses comp as if statmen var >= new int   

#if true subtract from pointer
<+31>:    sub    DWORD PTR [rbp-0x4],0x65
<+35>:    jmp    0x555555555152 <main+41>

#else statment that adds to pointer  
<+37>:    add    DWORD PTR [rbp-0x4],0x65

#returning the value  
<+41>:    mov    eax,DWORD PTR [rbp-0x4]

#epilouge 
<+44>:    pop    rbp
<+45>:    ret

I recreated the [code](rev4.c) in c

When running it i get the output:

    654773

## Flag

picoCTF{654773}

## Mitigation

The numbers in the code could of been encrypted so that only the person who made the code could reverse it. 
